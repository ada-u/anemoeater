#!/usr/bin/perl

########################################################################
# Copyright (C) 2016  yoku0825
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
########################################################################

use strict;
use warnings;
use utf8;

use FindBin qw/$Bin/;
use Time::Piece;
use File::Basename qw/basename/;
use DBI;
use Parallel::ForkManager;
use Getopt::Long qw/:config posix_default bundling no_ignore_case gnu_compat/;

use constant TIME_FORMAT => ["%Y/%m/%d %H:%M:%S",
                             "%Y/%m/%d %H:%M",
                             "%Y/%m/%d",
                             "%Y-%m-%d %H:%M:%S",
                             "%Y-%m-%d %H:%M",
                             "%Y-%m-%d",
                             "%Y%m%d%H%M%S",
                             "%Y%m%d%H%M",
                             "%Y%m%d"];

usage("/usr/bin/pt-query-digest isn't executable .") unless -x "/usr/bin/pt-query-digest";

my $opt= {parallel => 2,
          since    => "1970/1/1",
          until    => "9999/12/31",
          report   => 15,
          cell     => 5,
          help     => 0,
          docker   => 1,
          local    => 0,
         };
GetOptions($opt, qw/socket=s host=s port=i user=s password=s
                    parallel=i since=s until=s report=i cell=i
                    help usage no-docker local/) or die;
usage() if $opt->{help} || $opt->{usage};
usage("--cell should not be 0") unless $opt->{cell};
my $since= parse_time($opt->{since}, &TIME_FORMAT);
usage("Can't parse --since") unless $since;
my $until= parse_time($opt->{until}, &TIME_FORMAT);
usage("Can't parse --until") unless $until;
$opt->{docker}= 0 if $opt->{"no-docker"};

my @files= @ARGV;

foreach my $file (@files)
{
  usage("Slow log $file can't read.") unless -r $file;
}

### Starting docker container.
if ($opt->{docker})
{
  my $repository;
  if ($opt->{local})
  {
    $repository= "anemoeater";
    system("sudo docker build -t anemoeater $Bin");
  }
  else
  {
    $repository= "yoku0825/anemoeater";
  }

  my $container_id= `sudo docker run -d -P $repository`;
  chomp($container_id);

  my $container_ipaddr= `sudo docker inspect -f '{{.NetworkSettings.IPAddress}}' $container_id`;
  chomp($container_ipaddr);

  my $publish_port= `sudo docker inspect $container_id | awk '/HostPort/{print \$2}' | tr -d \\"`;
  chomp($publish_port);

  ### wait container's mysqld starts to run
  while ()
  {
    eval
    {
      my $conn= DBI->connect("dbi:mysql:;host=$container_ipaddr", "anemometer", "",
                             {RaiseError => 1, PrintError => 0});
      $conn->do("SELECT CURRENT_USER()");
    };

    last unless $@;
    sleep 3;
  }

  $opt->{host}    = $container_ipaddr;
  $opt->{user}    = "anemometer";
  $opt->{password}= undef;
  $opt->{port}    = undef;

  printf("Docker container starts with $container_ipaddr.\n");
  printf("URL will be http://$ENV{HOSTNAME}:$publish_port/anemometer\n");
}

my $pt_dsn= "D=slow_query_log";
$pt_dsn  .= sprintf(",h=%s", $opt->{host})     if $opt->{host};
$pt_dsn  .= sprintf(",P=%d", $opt->{port})     if $opt->{port};
$pt_dsn  .= sprintf(",u=%s", $opt->{user})     if $opt->{user};
$pt_dsn  .= sprintf(",p=%s", $opt->{password}) if $opt->{password};

my $cmd_format= qq{| /usr/bin/pt-query-digest --no-version-check --review %s --history %s --no-report --limit=0%% --filter="\\\$event->{Bytes} = length(\\\$event->{arg}) and \\\$event->{hostname}='%s'" > /dev/null};


my $pm  = Parallel::ForkManager->new($opt->{parallel});

foreach my $file (@files)
{
  open(my $in, "<", $file);

  my $event  = 0;
  my $timetmp= 0;
  my $current_time;
  my $previous_time;
  my @buffer = ();
  while (<$in>)
  {
    if (/^# Time: (?<timestr>.+)$/)
    {
      if ($+{timestr} =~ /(?<year>\d{2})(?<month>\d{2})(?<day>\d{2})\s+
                          (?<hour>\d{1,2}):(?<minute>\d{2}):(?<second>\d{2})/x)
      {
        ### 5.0, 5.1, 5.5, 5.6 style.
        # "# Time: %02d%02d%02d %2d:%02d:%02d\n",
  
        ### normalize without seconds.
        $timetmp= sprintf("20%02d%02d%02d%02d%02d",
                          $+{year}, $+{month}, $+{day},
                          $+{hour}, $+{minute}, $+{second});
  
      }
      elsif ($+{timestr} =~ /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})T
                             (?<hour>\d{2}):(?<minute>\d{2}):(?<second>\d{2})\.
                             (?<fraction>\d{6})(?<timezone>.*)/x)
      {
        ### 5.7 style.
        # "%04d-%02d-%02dT%02d:%02d:%02d.%06lu%s",
   
        ### normalize without seconds.
        $timetmp= sprintf("%04d%02d%02d%02d%02d",
                          $+{year}, $+{month}, $+{day},
                          $+{hour}, $+{minute}, $+{second});
      }
      else
      {
        ### Unknown format.
        $timetmp= 0;
      }
  
      $current_time= Time::Piece->strptime($timetmp, "%Y%m%d%H%M%S");
  
      if (!($previous_time) || ($current_time - $previous_time) >= ($opt->{cell} * 60))
      {
        $event= &send_pt_qd($current_time, $event, $file, @buffer);
        $previous_time= $current_time;
        @buffer= ();
      }
    }
    push(@buffer, $_);
  }
  
  ### flush last block.
  &send_pt_qd($current_time, $event, $file, @buffer) if @buffer;
  
  $pm->wait_all_children;
  
  
  ### Update hostname_max by filename.
  my $dsn     = "dbi:mysql:slow_query_log";
  $dsn       .= sprintf(";host=%s", $opt->{host}) if $opt->{host};
  $dsn       .= sprintf(";port=%d", $opt->{port}) if $opt->{port};
  my $user    = $opt->{user} ? $opt->{user} : "anemometer";
  my $password= $opt->{password} ? $opt->{password} : "";
  
  my $conn= DBI->connect($dsn, $user, $password, {mysql_use_utf8 => 1});
  $conn->do("UPDATE global_query_review_history SET hostname_max= REPLACE(?, '.log', '') WHERE hostname_max= ?",
            undef,
            basename($file), $ENV{HOSTNAME});

} 


exit 0;


sub usage
{
  my ($msg)= @_;

  print $msg, "\n" if $msg;
  print << "EOF";
$0 [--user=s] [--password=s] [--port=i] [--host=s] [--socket=s]
   [--parallel=i] [--since=i] [--until=i] [--report=i] [--docker] slowlog

  $0 is split slowlog and process by pt-query-digest.

  --user=s     MySQL user which pt-query-digest uses to connection.
  --password=s MySQL password which pt-query-digest uses to connection.
  --port=i     MySQL port which pt-query-digest uses to connection.
  --host=s     MySQL host which pt-query-digest uses to connection.
  --socket=s   MySQL socket which pt-query-digest uses to connection.
  --parallel=i How many processes does script run concurrently (default: 2)
  --since=i    Filter for processing slow-log, YYYYMMDDHHNN style only.
  --until=i    Filter for processing slow-log, YYYYMMDDHHNN style only.
  --report=i   Print message each processed events n times (default: 100)
  --no-docker  Do not use docker image. Must specify --user, --password, --port and --host.
  --local      Using docker container but using local built(Do not use yoku0825/anemoeater)
EOF
  exit 0;
}


sub parse_time
{
  my ($timestr, $candidate)= @_;
  my $ret;

  foreach (@$candidate)
  {
    eval
    {
      $ret= Time::Piece->strptime($timestr, $_);
    };

    return $ret unless $@;
  }
}


sub send_pt_qd
{
  my ($current_time, $event, $file, @buffer)= @_;
  return 0 unless ($since <= $current_time && $current_time <= $until);
  printf("processing %s %s at %s.\n", $current_time->ymd, $current_time->hms, basename($file))
    if ($opt->{report} && (++$event % $opt->{report}) == 0);

  unless ($pm->start)
  {
    open(my $process, sprintf($cmd_format,
                              $pt_dsn . ",t=global_query_review",
                              $pt_dsn . ",t=global_query_review_history",
                              $ENV{HOSTNAME}));
    print $process @buffer;
    close($process);
    $pm->finish;
  }

  return ++$event;
}


